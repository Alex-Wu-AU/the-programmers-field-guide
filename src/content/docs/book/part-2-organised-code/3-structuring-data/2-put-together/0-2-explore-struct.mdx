---
title: Explore Structs
sidebar:
    label: " - Explore Structs"
---
import { Accordion, AccordionItem } from 'accessible-astro-components'


Structs are a great way of being able to capture all the data for something (an entity) related to your program. Let's explore how to create an use a struct within a small graphical program.

In this program we are going to show a target on the screen and record the time the user takes to "hit" this target with the mouse. We can report accuracy and average time to the user as the program runs.

## Target struct

When starting to build this program, the first thing we should think about are the *entities* (things) we will want to work with inside the program.

For this program, the main *thing* that I can see is the need for a *target*. Each target will need to know where it is on the screen (x and y) as well as its size. When I think of a target I imagine it will be a circle, so the size in this case can be a radius for the target. That gives us:

|   |   |
|---|---|
| **Struct** | *target_data* |
| **Fields** | `x`: Distance from the left of the window |
|            | `y`: Distance from the top of the window |
|            | `radius`: Size of the target |

This is enough to get started building this. Here is a start to `main` that we can add the target to. The logic shown here adds in the event loop, and creates a target in main which will contain the details about the target shown to the user.

Declare the `target_data` struct to get started with this change.

```cpp
#include "splashkit.h"

// Declare target_data struct here

int main()
{
  open_window("Reaction Timer", 800, 600);

  target_data target;
  
  while (!quit_requested())
  {
    process_events();
    
    clear_screen(COLOR_WHITE);
    refresh_screen();
  }
  
  return 0;
}
```

<Accordion>
  <AccordionItem
    header="Code for target data struct"
  >

```cpp
struct target_data
{
  double x;
  double y;
  double radius;
};
```

  </AccordionItem>
</Accordion>

When you run this it will only show a white screen, so the next step should be to add some code to initialise and draw the target.

## Initialise and draw the target

Before we can draw a target, we need to be able to initialise the values within the target. This requires us to set `x`, `y`, and `radius` values.

Update the code in `main` so that `target` is given a value for it's x, y, and radius fields.

In order to see what is happening, let's next add a `draw_target` procedure. We can start with a simple circle and make this more target like in a future iteration.

|   |   |
|---|---|
| **Procedure** | *Draw Target* |
| **Parameters** | `target`: The target to draw (a target_data value). |
| **Description** | Draws a filled circle to the screen at the target's location. |

Have a go at adding the code to initialise target in main, add and call the `draw_target` procedure. A start for this is shown in the code below. For drawing the target you can use SplashKit's [fill circle](https://splashkit.io/api/graphics/#fill-circle-3) procedure.

```cpp
#include "splashkit.h"

// Declare target_data struct here

// Add draw target here

int main()
{
  open_window("Reaction Timer", 800, 600);

  target_data target; // initilise target here
  
  while (!quit_requested())
  {
    process_events();
    
    clear_screen(COLOR_WHITE);
    // Draw the target
    draw_target(target);
    refresh_screen();
  }
  
  return 0;
}
```

<Accordion>
  <AccordionItem
    header="Code for initialising and drawing a target"
  >

There are a couple of ways you can initialise `target`. The first is to set each of the fields separately. This would be achieved using the following code.

```cpp
// Declare and initialise a target variable
target_data target;
target.x = 400;
target.y = 300;
target.radius = 75;
```

Alternative, you can use an initialiser in the variable declaration. This type of assignment can only happen when you declare a variable. You cannot use it at a later stage to change the values in that variable.

```cpp
// Declare and initialise a target variable
target_data target = {400, 300, 75};
```

:::caution
With this assignment you list the values in the order they appear in the struct itself. If you ever change the order of fields in the struct, this may break these initialisers.
:::

For `draw_target` you would need something like the following code. The key parts are the parameter is a `target_data` value, and you can then access the fields of that type within the procedure itself. Notice how this accepts the target data as a whole, but can then access the parts that it needs.

```cpp
void draw_target(target_data target)
{
  fill_circle(COLOR_LIGHT_BLUE, target.x, target.y, target.radius);
}

```

  </AccordionItem>
</Accordion>

Make sure to build and run your program. You should see the target drawn at the location where you positioned the target. Try changing the values you used to initialise the target, and you should see this reflected when you build and run the program again.

## Improve target initialisation

At the moment we initialise the target in main, but we really want to be able to position this to a random location. We can break this down into two related functions: `new_target` and `random_target`. The `new_target` function can initialise and return a target based on values provided to its parameters. The `random_target` function can then use `new_target` and pass in random values for the position and size of the target.

|   |   |
|---|---|
| **Function** | *New Target* |
| **Parameters** | `x`: The x value for the target. |
|                | `y`: The y value for the target. |
|                | `radius`: The target's radius. |
| **Returns** | A target at the indicated location, with the indicated size. |
| **Description** | New target is used to initialise a target. The passed in parameters allow the caller to adjust the location and size of the target as they desire. |

Within `random_target` we can call `new_target` to perform the initialisation. This means that `random_target` can focus just on the values for the random target's position and size. SplashKit includes functions to generate random values which we can use. To keep the target on the screen it's `x` value must be larger than its radius, and less than the width of the screen minus its radius. We can apply the same logic to the `y` value and the screen height. For the radius we can declare some constants for `MIN_TARGET_RADIUS` and `MAX_TARGET_RADIUS`.

Have a look at the [rnd](https://splashkit.io/api/utilities/#rnd-1) function in SplashKit. There are several versions of this, one that generates a random value between a min and max ([rnd](https://splashkit.io/api/utilities/#rnd-1)) one that generates a random real value between 0 and 1 ([rnd](https://splashkit.io/api/utilities/#rnd-2)) and one that generates a random integer up to a particular value ([rnd](https://splashkit.io/api/utilities/#rnd-3)).

|   |   |
|---|---|
| **Function** | *Random Target* |
| **Returns** | A target at a random location and size. |
| **Description** | Random target will return target data for a target using the current screen size as its bounds. This will ensure that the target can be drawn and seen entirely on the screen. |

Have a think about how you can implement this function. You may want to add a `radius` local variable, and then use that as you calculate random values for the x and y position. Leave the initialisation of the target to `new_target`, this way if we change things in the target struct there is just one place where we initialise target values.

```cpp
#include "splashkit.h"

// Declare target_data struct here

// Add new target here

// Add random target here

// Add draw target here

int main()
{
  open_window("Reaction Timer", 800, 600);

  // Create a random target
  target_data target = random_target();
  
  while (!quit_requested())
  {
    process_events();
    
    clear_screen(COLOR_WHITE);
    // Draw the target
    draw_target(target);
    refresh_screen();
  }
  
  return 0;
}
```

<Accordion>
  <AccordionItem
    header="Code for new target and random target"
  >

For `new_target` I chose to initialise the fields one at a time. This way any future change to the struct will not negatively impact this code.

```cpp
target_data new_target(double x, double y, double radius)
{
  target_data result;
  result.x = x;
  result.y = y;
  result.radius = radius;
  return result;
}
```

For `random_target` I am using two versions of the [rnd](https://splashkit.io/api/utilities/#rnd-1) function. For the radius I am using the version that returns a random integer. To ensure we have a minimum radius, the random is up to `MAX_TARGET_RADIUS - MIN_TARGET_RADIUS`, to which I then add `MIN_TARGET_RADIUS`. For the location of the target I used the version that takes a range (a min and max). In our case, the minimum can be the radius of the circle, and the maximum is the screen width or height minus the radius. In this way we ensure that the target will be on the screen.

```cpp
target_data random_target()
{
  int radius = rnd(MAX_TARGET_RADIUS - MIN_TARGET_RADIUS) + MIN_TARGET_RADIUS;

  return new_target(
    rnd(radius, screen_width() - radius), 
    rnd(radius, screen_height() - radius), 
    radius
  );
}
```

  </AccordionItem>
</Accordion>

Each time you run this, you should see the target at a different location.

## Hitting the target

When the user clicks, we want to be able to check if they have hit the target. To implement this we can create a `mouse_over_target` function. This can check if the mouse is over the target. Main can then use this new function with an if statement, inside which it can set the target to a new target for the user to click.

To implement this we can use the [point_in_circle](https://splashkit.io/api/geometry/#point-in-circle-2) function. This function accepts parameters for the point x and y (which we can get from [mouse_x](https://splashkit.io/api/input/#mouse-x) and [mouse_y](https://splashkit.io/api/input/#mouse-y)) and the x, y, and radius of the circle (which we can get from the target).

|   |   |
|---|---|
| **Function** | *Mouse Over Target* |
| **Parameters** | `target` the target we are testing |
| **Returns** | True if the user has clicked, and their mouse is over the target. |
| **Description** | Check and return a boolean that indicates if the mouse is over the target. |

Inside `main` we can add a check to see if the mouse was clicked (using [mouse_clicked](https://splashkit.io/api/input/#mouse-clicked)) and it is over the target. When this is true, you can replace the target with new target data.

Have a go at this yourself.

<Accordion>
  <AccordionItem
    header="Code for main and mouse over target"
  >

```cpp
#include "splashkit.h"

// Declare target_data struct here

// Add new target here

// Add random target here

// Add draw target here

// Add mouse over target here

int main()
{
  open_window("Reaction Timer", 800, 600);

  // Create a random target
  target_data target = random_target();
  
  while (!quit_requested())
  {
    process_events();

    if (mouse_clicked(LEFT_BUTTON) && mouse_over_target())
    {
        target = random_target();
    }
    
    clear_screen(COLOR_WHITE);
    // Draw the target
    draw_target(target);
    refresh_screen();
  }
  
  return 0;
}
```

The `mouse_over_target` can be implemented in a single line of code - but this will still help make our code more readable.

```cpp
bool mouse_over_target(target_data target)
{
  return point_in_circle(mouse_x(), mouse_y(), target.x, target.y, target.radius);
}
```

  </AccordionItem>
</Accordion>

